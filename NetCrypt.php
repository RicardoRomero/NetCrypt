<?php

namespace Marinvs;

/**
 * Heavily borrowed from http://php.net/manual/en/function.openssl-encrypt.php#120141
 * The difference is that the ciphertext generated by this class can be used with openssl_decrypt. See the tests:
 *
 *
 * This file is provided only as reference. This file as-is is NOT suitable for use in production environments.
 *
 * The encrypted file:
 *
 * - The first 16 bytes contain the initialization vector
 * - The next byte contains the decrypted file size modulo 16 in least significant bit positions
 * - The rest of the bytes contain the ciphertext
 *
 *
 * References:
 *     https://en.wikipedia.org/wiki/Block_size_(cryptography)
 *     https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation (CBC)
 *     https://www.aescrypt.com/aes_file_format.html (This class does NOT implement AES format)
 */
class NetCrypt
{
    /**
    * Define the number of blocks that should be read from the source file for each chunk.
    * For 'AES-256-CBC' and AES in general, each block consists of 16 bytes.
    * So if we read 10,240 blocks we load 160kb into memory. You may adjust this value
    * to read/write shorter or longer chunks.
    */
    const FILE_ENCRYPTION_BLOCKS = 10240;
    const BLOCK_SIZE = 16;

    /**
     * openssl_cipher_iv_length('AES-256-CBC') = 16
     */
    const IV_LENGTH = 16;
    const KEY_LENGTH = 16; // 16, 24 or 32 bytes
    const METHOD = 'AES-256-CBC';

    /**
    * Encrypt the passed file and saves the result in a new file with ".enc" as suffix.
    *
    * @param string $source Path to file that should be encrypted
    * @param string $key    The key used for the encryption
    * @param string $dest   File name where the encryped file should be written to.
    * @return string|false  Returns the file name that has been created or FALSE if an error occured
    */
    public static function encryptFile($source, $key, $dest)
    {
        $openedOut = false;
        if ($fpOut = fopen($dest, 'w')) {
            $openedOut = true;
        }
        if (!$openedOut) {
            return false;
        }
        $openedIn = false;
        if ($fpIn = fopen($source, 'rb')) {
            $openedIn = true;
        }
        if (!$openedIn) {
            fclose($fpOut);
            
            return false;
        }

        $hexModulo = dechex(filesize($source) % self::BLOCK_SIZE);
        // fill to 1 byte
        while (strlen($hexModulo) < 2) {
            $hexModulo = '0'.$hexModulo;
        }
        $binModulo = hex2bin($hexModulo);

        // Ready to start
        $key = substr(hash('sha256', $key, true), 0, self::KEY_LENGTH);
        $iv = openssl_random_pseudo_bytes(self::IV_LENGTH);

        $chunkBytes = self::BLOCK_SIZE * self::FILE_ENCRYPTION_BLOCKS;
        
        $error = false;
        $ciphertext = '';
        // Put the initialzation vector to the beginning of the file
        fwrite($fpOut, $iv.$binModulo);
        while (!feof($fpIn)) {
            $plaintext = fread($fpIn, $chunkBytes);
            $ciphertext = openssl_encrypt($plaintext.self::getPadding(strlen($plaintext)), self::METHOD, $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $iv);

            // Use the last bytes of the ciphertext as the next initialization vector
            $iv = substr($ciphertext, -self::IV_LENGTH);
            fwrite($fpOut, $ciphertext);
        }
        fclose($fpIn);
        fclose($fpOut);

        return $error ? false : $dest;
    }

    /**
    * Dencrypt the passed file and saves the result in a new file, removing the
    * last 4 characters from file name.
    *
    * @param string $source Path to file that should be decrypted
    * @param string $key    The key used for the decryption (must be the same as for encryption)
    * @param string $dest   File name where the decryped file should be written to.
    * @return string|false  Returns the file name that has been created or FALSE if an error occured
    */
    public static function decryptFile($source, $key, $dest)
    {
        $openedOut = false;
        if ($fpOut = fopen($dest, 'w')) {
            $openedOut = true;
        }
        if (!$openedOut) {
            return false;
        }
        $openedIn = false;
        if ($fpIn = fopen($source, 'rb')) {
            $openedIn = true;
        }
        if (!$openedIn) {
            fclose($fpOut);
            
            return false;
        }
        // Ready to start
        $key = substr(hash('sha256', $key, true), 0, self::KEY_LENGTH);
        $chunkBytes = self::BLOCK_SIZE * (self::FILE_ENCRYPTION_BLOCKS);

        $error = false;

        // Get the initialzation vector and the file size modulo 16 from the beginning of the file
        $iv = fread($fpIn, 16);
        $binModulo = fread($fpIn, 1);
        $decModulo = hexdec(bin2hex($binModulo));

        while (!feof($fpIn)) {
            $ciphertext = fread($fpIn, $chunkBytes);
            $plaintext = openssl_decrypt($ciphertext, self::METHOD, $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $iv);
            // Use the last bytes of the ciphertext as the next initialization vector
            $iv = substr($ciphertext, -self::BLOCK_SIZE);

            $plaintext = strlen($ciphertext) < $chunkBytes ? self::removePadding($plaintext, $decModulo) : $plaintext;

            fwrite($fpOut, $plaintext);
        }
        fclose($fpIn);

        fclose($fpOut);
  

        return $error ? false : $dest;
    }

    public static function getPadding(int $size)
    {
        $r = $size % self::BLOCK_SIZE;

        if ($r === 0) { // No padding
            return '';
        }

        $p = self::BLOCK_SIZE - $r;

        $str = '';
        for ($i = 0; $i < $p; $i++) {
            $str .= '00';
        }

        return hex2bin($str);
    }

    protected static function removePadding(string $plaintext, int $modulo)
    {
        if ($modulo === 0) { // Do nothing
            return $plaintext;
        }

        $p = self::BLOCK_SIZE - $modulo;

        return substr($plaintext, 0, strlen($plaintext) - $p);
    }
}
